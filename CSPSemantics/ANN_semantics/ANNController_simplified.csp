--This is currently setup to be equivalent to, with discretised types, as the Segway AnglePID controller, with constants:
--P = 1, I = 0 and D = 0. 
module ANNSimp
exports
    --CHANNELS--
	
	--RoboChart linking channels--
	channel angleOutputE:InOut.core_real
	channel adiff:InOut.core_real
	channel anewError:InOut.core_real
	
	--ANN Channels--
	channel layerRes:{0..layerNo}.{1..maxSize}.Value
	channel nodeOut:{1..layerNo}.{1..maxSize}.{1..maxSize}.Value
    
	--Termination Channel (not used)--
	channel terminate
	
	--SEMANTIC CONSTANTS--

	insize = 6
	outsize = 3
	layerstructure = <3, 3> 
	layerNo = #layerstructure 
	maxSize = 6

	weights = < < <1,0,0,0,0,0>, <0,1,0,0,0,0>, <0,0,1,0,0,0> >, < <1,0,0>, <0,1,0>, <0,0,1> > >
	biases = < <0,0,0>, <0,0,0>>

	Value = {0,1}
	
	
    --HELPER FUNCTIONS--
	
	extract_sequence(1, sequence) = head(sequence)
	extract_sequence(index, sequence) = extract_sequence((index-1), tail(sequence))

	layerSize(0) = insize
	layerSize(layer) = extract_sequence(layer, layerstructure)
	
	extract_weights(layer, node, index) = extract_sequence(index, 
											(extract_sequence(node, 
												(extract_sequence(layer, weights)))))

	extract_biases(layer, node) = (extract_sequence(node, 
												(extract_sequence(layer, biases))))

    --BINARY TO CORE_REAL TYPE TRANSLATION FUNCTIONS--
	binary_to_core_real(seq, 0, sum) = sum
	binary_to_core_real(seq, n, sum) = binary_to_core_real(tail(seq), (n-1), sum + (head(seq) * binary(n)) )

	binary_to_cr(seq) = binary_to_core_real(seq, 3, 0) - 3

	corereal_to_binary(1) = <0,0,1>
	corereal_to_binary(2) = <0,1,0>
	corereal_to_binary(3) = <0,1,1>
	corereal_to_binary(4) = <1,0,0>
	corereal_to_binary(5) = <1,0,1>

	cr_to_binary(val) = corereal_to_binary(val+3)

	binary_rec(1, sum) = sum
	binary_rec(n, sum) = binary_rec(n-1, sum * 2)
	binary(n) = binary_rec(n, 1)
    
	--INPUTPROCESS AND OUTPUTPROCESS DEFINITIONS --
	
	InputProcess = anewError.in?in_ -> adiff.in?in2_ -> InputProcessRaw(in_, in2_)

	InputProcessRaw(in_, in2_) = InputProcessBinary(cr_to_binary(in_), 1); InputProcessBinary(cr_to_binary(in2_), 4); SKIP

	--1 2 3 is first input, x, 4 5 6 is second input.
	InputProcessBinary(<>, _) = SKIP
	InputProcessBinary(seq, index) = layerRes.0.index.(head(seq)) -> InputProcessBinary(tail(seq), index+1)

	OutputProcess = layerRes.2.1?in11 -> layerRes.2.2?in12 -> layerRes.2.3?in13 -> OutputProcessConverted(in11, in12, in13)

	OutputProcessConverted(in11, in12, in13) = OutputProcessCR(binary_to_cr(<in11, in12, in13>)); SKIP

	OutputProcessCR(val) = (val >= -2 and val <= 2) & angleOutputE.out.val -> SKIP


	--ANN PROCESS DEFINITIONS --
	
	ANNHiddenEvts = diff(Events, {| layerRes.0, layerRes.2, end |})

	HiddenLayers = || i : {1..(layerNo-1)} @ [ {| layerRes.(i-1), layerRes.i |} ] HiddenLayer(i, layerSize(i), layerSize(i-1))  
	

	HiddenLayer(layer, size, inputSize) = [| {| layerRes.(layer-1) |} |] i: {1..size} @ Node(layer, i, inputSize) 


	Node(layer, node, inputSize) = (||| i:{1..inputSize} @ NodeIn(layer, node, i)) [| {| nodeOut.layer.node |} |] Collator(layer, node, inputSize) \ {| nodeOut |}

	NodeIn(layer, node, index) = layerRes.(layer - 1).index?x -> nodeOut.layer.node.index.(x * extract_weights(layer, node, index)) -> SKIP

	--Sign is the sign binary activation function.
	sign(x) = if (x > 0) then 1 else 0

	Collator(layer, node, index) = 
	let
		C(layer, node, 0, sum) = layerRes.layer.node.sign(sum + extract_biases(layer, node)) -> SKIP
		C(layer, node, index, sum) = nodeOut.layer.node.index?n -> C(layer, node, (index-1), (sum+n))
	within 
		C(layer, node, index, 0)

	OutputLayer = [| {| layerRes.(layerNo-1) |} |] i: {1..layerSize(layerNo)} @ Node(layerNo, i, layerSize(layerNo-1))

    --This is complete semantic function. 
	ANN = (( (HiddenLayers [| {| layerRes.1 |} |] OutputLayer) \ ANNHiddenEvts ) [|{|terminate|}|>SKIP)  
	
    --This is required to translate types from core_real to binary and to link to the rest of the system, and hide layerRes events. 
	Full = ( ( (InputProcess [| {| layerRes.0 |} |] ANN) [| {| layerRes.2 |} |] OutputProcess ) \ {| layerRes |} ) ; Full
endmodule
