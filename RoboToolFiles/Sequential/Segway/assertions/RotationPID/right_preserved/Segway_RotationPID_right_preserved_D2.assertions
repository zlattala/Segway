timed csp constrain
csp-begin
	constrain(x, min, max) = if x < min then min else if x > max then max else x
csp-end

timed csp SegwayRPEvents
csp-begin
	SegwayRPEvents = {| 
		Segway::angle.in,
		Segway::gyroX.in,
		Segway::gyroY.in,
		Segway::gyroZ.in,
		Segway::leftMotorVelocity.in,
		Segway::rightMotorVelocity.in,
		Segway::setLeftMotorSpeedCall,
		Segway::setRightMotorSpeedCall,
		Segway::disableInterruptsCall,
		Segway::enableInterruptsCall
	|}
csp-end

// define range from -maxAngle to maxAngle and its complement
timed csp AngleRange
csp-begin
	AngleRange = { -2..2 } 
csp-end
timed csp OutsideAngleRange
csp-begin
	OutsideAngleRange = diff(core_real, AngleRange)
csp-end

timed csp AngleInRange
csp-begin
	AngleInRange = { Segway::angle.in.x | x <- AngleRange}
csp-end

timed csp AngleOutsideRange
csp-begin
	AngleOutsideRange = { Segway::angle.in.x | x <- OutsideAngleRange}
csp-end

// When RotationPID::D is set to one (and all other PID constants are zero), 
// after the first (rotationUpdate-1) times setRightMotorSpeed() has occurred,
// the next value passed to setRightMotorSpeed()
//		when the value communicated by angle is greater than or equal to -maxAngle and less than or equal to maxAngle
// is passed to setRightMotorSpeed()
//		whenever the value communicated by angle is greater than or equal to -maxAngle and less than or equal to maxAngle
//		until rotationUpdate further occurrences of setRightMotorSpeed() (after the initial rotationUpdate-1) have happened, after which it repeats (from "the next value passed...")
timed csp RotationPIDProp6
csp-begin
	Timed(OneStep) {
		RotationPIDProp6 = RotationPIDProp6Count(0)
		
		-- RotationPIDProp6Count represents the state when fewer than rotationUpdate motor settings have occurred and we count the right motor settings
		RotationPIDProp6Count(count) =
			-- allow any events other than setting right speed
			([] e : diff(SegwayRPEvents, {|Segway::setRightMotorSpeedCall|}) @ e -> RotationPIDProp6Count(count))
			 []
			-- allow setRightMotorSpeedCall to occur with any values and update the count for the first rotationUpdate-2 times
			(count < const_BalanceSTM_rotationUpdate-2) & Segway::setRightMotorSpeedCall?x -> RotationPIDProp6Count(count+1)
			 []
			-- allow setRightMotorSpeedCall to occur with any values for the (rotationUpdate-1)th time,
			-- then we reset the count and check the angle
			(count == const_BalanceSTM_rotationUpdate-2) & Segway::setRightMotorSpeedCall?x -> RotationPIDProp6AngleCheck(0)
			
		-- RotationPIDProp6AngleCheck represents the state in which we are waiting for the angle to be in range before we can record the setRightMotorSpeed() value
		RotationPIDProp6AngleCheck(count) =
			-- allow any events other than setting right speed and getting angle
			([] e : diff(SegwayRPEvents, {|Segway::angle, Segway::setRightMotorSpeedCall|}) @ e -> RotationPIDProp6AngleCheck(count))
			 []
			-- allow setRightMotorSpeedCall to occur with any values, since we haven't had an angle in range, and update the count mod rotationUpdate
			Segway::setRightMotorSpeedCall?x -> RotationPIDProp6AngleCheck(if count < const_BalanceSTM_rotationUpdate-1 then count+1 else 0)
			 []
			-- if the angle is out of range, continue
			Segway::angle.in?x : OutsideAngleRange -> RotationPIDProp6AngleCheck(count)
			 []
			-- if the angle is in range, go to a state where we can record the next value of setRightMotorSpeedCall
			Segway::angle.in?x : AngleRange -> RotationPIDProp6RecordValue(count)
			
		-- RotationPIDProp6RecordValue represents the state in which angle is in range and we are waiting to record the setRightMotorSpeed() value
		RotationPIDProp6RecordValue(count) =
			-- allow any events other than setting right speed and getting angle
			([] e : diff(SegwayRPEvents, {|Segway::angle, Segway::setRightMotorSpeedCall|}) @ e -> RotationPIDProp6RecordValue(count))
			 []
			-- if an angle in range occurs, continue
			Segway::angle.in?x : AngleRange -> RotationPIDProp6RecordValue(count)
			 []
			-- if an angle out of range occurs, return to checking for an angle in range
			Segway::angle.in?x : OutsideAngleRange -> RotationPIDProp6AngleCheck(count)
			 []
			-- if this isn't the rotationUpdate-th occurrence, when setRightMotorSpeedCall occurs, record the value and increment the count
			(count < const_BalanceSTM_rotationUpdate-1) & Segway::setRightMotorSpeedCall?x -> RotationPIDProp6InRange(count+1, x)
			 []
			-- if this is the rotationUpdate-th occurrence of setRightMotorSpeedCall, go back to checking the angle to start a new cycle
			(count == const_BalanceSTM_rotationUpdate-1) & Segway::setRightMotorSpeedCall?x -> RotationPIDProp6AngleCheck(0)
			
		-- RotationPIDProp6InRange represents the state where the angle is in range and the same value is repeatedly output for setRightMotorSpeed()
		RotationPIDProp6InRange(count, value) =
			-- allow any events other than setting right speed and getting angle
			([] e : diff(SegwayRPEvents, {|Segway::angle, Segway::setRightMotorSpeedCall|}) @ e -> RotationPIDProp6InRange(count, value))
			 []
			-- allow setRightMotorSpeedCall to occur outputting value and update the count for the first rotationUpdate-1 times
			(count < const_BalanceSTM_rotationUpdate-1) & Segway::setRightMotorSpeedCall!value -> RotationPIDProp6InRange(count+1, value)
			 []
			-- allow setRightMotorSpeedCall to occur outputting value for the rotationUpdate-th time, then discard the value and reset the count
			(count == const_BalanceSTM_rotationUpdate-1) & Segway::setRightMotorSpeedCall!value -> RotationPIDProp6AngleCheck(0)
			 []
			-- if angle is in range, continue
			Segway::angle.in?x : AngleRange -> RotationPIDProp6InRange(count, value)
			 []
			-- if angle is out of range, switch to have no bounds on the setRightMotorSpeed() value, but keep value recorded
			Segway::angle.in?x : OutsideAngleRange -> RotationPIDProp6OutOfRange(count, value)
		
		-- RotationPIDProp6InRange represents the state where the angle is out of range and setRightMotorSpeed() is unrestricted
		RotationPIDProp6OutOfRange(count, value) =
			-- allow any events other than setting right speed and getting angle
			([] e : diff(SegwayRPEvents, {|Segway::angle, Segway::setRightMotorSpeedCall|}) @ e -> RotationPIDProp6OutOfRange(count, value))
			 []
			-- allow setRightMotorSpeedCall to occur with any values, since we haven't had an angle in range, and update the count
			(count < const_BalanceSTM_rotationUpdate-1) & Segway::setRightMotorSpeedCall?x -> RotationPIDProp6OutOfRange(count+1, value)
			 []
			-- allow setRightMotorSpeedCall to occur with any values, since we haven't had an angle in range, and reset the count and discard the value
			(count == const_BalanceSTM_rotationUpdate-1) & Segway::setRightMotorSpeedCall?x -> RotationPIDProp6AngleCheck(0)
			 []
			-- if angle is out of range, continue
			Segway::angle.in?x : OutsideAngleRange -> RotationPIDProp6OutOfRange(count, value)
			 []
			-- if angle is in range, switch to constrain setRightMotorSpeed() value
			Segway::angle.in?x : AngleRange -> RotationPIDProp6InRange(count, value)
	}
csp-end
timed assertion RotationPIDProp6_refines: Segway refines RotationPIDProp6
	in the traces model
	with constant ^P of AnglePID    set to 0,
	     constant D  of AnglePID    set to 0,
	     constant ^P of SpeedPID    set to 0,
	     constant I  of SpeedPID    set to 0 and
	     constant D  of RotationPID set to 2